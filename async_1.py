# В рамках 1 потока.
# 2 типа задач: вычислительные(например, рендеринг видео) и IO задачи(ввод, вывод)
 
import socket


server_socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)
server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
server_socket.bind(('localhost', 5000))
server_socket.listen()

# это пример блокирующего метода accept()
# на этом методе внешний цикл "зависает" пока не будет принято подключение
# дам ему подключение командой терминала nc localhost 5000 (Linux)
# после выполения команды сдвигаемся дальше и видим получение информации о том, 
# кто подсоединился Connection from ('127.0.0.1', 53940)
# и теперь "зависаем" на следующем блокирующем методе send()

while True:
    print('До метода accept()')
    client_socket, addr = server_socket.accept() # блокирующий метод
    print(f'Connection from {addr}')

    while True:
        print('До метода recv()')
        request = client_socket.recv(4096)

        if not request:
            break
        else:
            respnse = f'Hello World\n'.encode()
            client_socket.send(respnse) # блокирующий метод
    
    client_socket.close()

# блокирующие операции, если просто, это операции, которые не позволяют
# выполнять последующий код, пока она сама не выполнится. То есть,
# в месте вызова данной операции она блокирует выполнение программы пока 
# не вернет результат свого выполнения и с результатом, она вернет контроль
# выполнения в то место, где его перехватила. 
# Забегая вперед, а что если при вызове таких операций, сразу что-нибудь
# возращать??..
# В данной реализации, при подключении еще одного клиента ничего не произойдет
# так как, сервер уже занят подключенным клиентом и мы "заперты" во втором цикле.
# Как выйти из этого цикла и принять подключение второго клиента, пока первый думает
# что написать?
# Этот вопрос и обрисовывает основную проблему, которую можно решить 
# конкурентныйм программированием.
