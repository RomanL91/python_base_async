# создание событийтиного цикла при помощи функции генераторов

# пример простого генератора
def generator(s_string):
    for char in s_string:
        yield char

g = generator(s_string='Roman')
# в переменную получим обьект генератора
# при помощи функции next() получим первую букву строки, которую передали в функции и все.
# при поворном вызовы next(g) получим следующую букву, главное, что функция как бы останавливается
# на паузу, где можно выполнить еще что-нибудь, а затем снова вызвать и получить следующую букву,
# продолжая с того же самого места(это важно)
# Фактически, функции генераторы отдают не только свое значение при заверщении, но и контроль 
# выполнения программы
# дело подходит к бесконечной функции генератора


# пример дальше
# бесконечный генератор 
from time import time


def generator_filename():
    while True:
        yield f'file-{time() * 1000}.txt'

        # в отличии от return после yield можно записать код, который будет исполнен
        # при повторном вызове. Например, проведем арифмитическую операцию 1+1

        num_sum = 1 + 1
        print(num_sum)

        # при 1ом вызове функции генератора, выполнение программы дойдет yield и вернет значение
        # все как обычно, но при повторном вызове, произойдет арифметика и принт и снова возрат
        # значения от слова  yield

        # есть еще одна особенность, yield может быть несколько!!!


# далее разбор событийного цикла(по типу карусели)


def num_generator(num):
    for i in range(num):
        yield f'это генератор с аргументом NUM --->>> {i}'


g = generator(s_string='Roman')
g1 = num_generator(5)

tasks = [g, g1]

while tasks:
    task = tasks.pop(0)

    try:
        i = next(task)
        print(i)
        tasks.append(task)
    except StopIteration:
        pass